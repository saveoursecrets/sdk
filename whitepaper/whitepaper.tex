\documentclass[a4paper,titlepage,oneside]{article}

% tt
\normalfont
\usepackage[T1]{fontenc}
\usepackage{setspace}
\usepackage{geometry}
\usepackage[parfill]{parskip}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{makeidx}
\usepackage{showidx}
\usepackage{url}
\usepackage{verbatim}
\usepackage{txfonts}
\usepackage{moreverb}
\usepackage{listings}
\usepackage{wallpaper}
\usepackage{fancyhdr}
\usepackage{hyperref}
\hypersetup{
colorlinks,
	linkcolor=blue,
	urlcolor=blue,
	bookmarks=true,
	bookmarksopen=true,
	pdffitwindow=true,
	pdftitle={Protocol for Web3 Secret Storage},
	pdfkeywords={invoice},
	pdfauthor={Muji}
}
\urlstyle{rm}
\pdfpagewidth=\paperwidth
\pdfpageheight=\paperheight

\renewcommand{\paragraph}{\small}
\title{Protocol for Web3 Secret Storage}
\author{Muji}

\makeindex

\begin{document}

\fancyhead{}
\fancyfoot{}

\lhead{\textbf{\textsc{Protocol for Web3 Secret Storage}}}
\rhead{\textbf{\textsc{}}}
\lfoot{\thepage}
\rfoot{\textsc{Last updated \today}}

\title{Protocol for secret storage using threshold signatures for secrets recovery in the event of death}

\author{Muji}

\maketitle

\tableofcontents

\section{Abstract}
\paragraph{People need to store secrets safely. An average person needs to store login passwords for online services and possibly other secrets such as SSH keys, GPG keys or other secret data. Now with the advent of cryptocurrencies people require the ability to store private keys that may hold considerable value. Storing these secrets using a trusted third-party service is a common practice for non-technical people however this poses risks such as the service provider geting hacked or a malicious employee attacking your data. Modern service providers will design a protocol that ensures that data is only decrypted on the client device and the master password never leaves the client device which provides confidence that the service provider cannot access secrets even if they are compromised.}

\paragraph{This protection against the service provider poses a problem for secrets recovery in the case of death. If the service provider cannot decrypt the secrets then they cannot release those secrets to family members in the case of the owner's death.}

\paragraph{The ability to pass on our secrets to loved ones upon death is important not only for social media accounts that may need to be closed but also access to bank accounts, cryptocurrency assets and other secrets that may be required for inheritance.}

\paragraph{We aim to show that it is possible to protect secrets using modern cryptography that allows for a high-level of confidence that your secrets are safe while alive and allowing family members to recover those secrets in the event of death.}

\section{Design Goals}

\begin{itemize}
  \item Secure design
  \item Recovery mechanism in the event of death
  \item Zero metadata leakage
  \item Self-hosted vaults
  \item Allow for untrusted hosting provider
  \item Cross-platform client implementations
  \item Allow applications to manage secrets in a vault using public / private key cryptography
  \item Support multi-user access with ACLs configurable by the owner
\end{itemize}

\subsection{Secure Design}

\paragraph{The cryptography to protect the secrets will use the XChaCha20Poly1305\footnote{\href{https://en.wikipedia.org/wiki/ChaCha20-Poly1305}{XChaCha20Poly1305}} symmetric cipher to protect the data at rest and ensure it's integrity using AEAD\footnote{\href{https://en.wikipedia.org/wiki/Authenticated_encryption}{Authenticated Encryption and Associated Data}}.}

\subsection{Recovery Mechanism}

\paragraph{Using cryptographic signatures for authentication to a vault access to the encrypted secrets can be restricted to single-parties or a quorum of trusted family members using threshold signatures.}

\paragraph{A quorum that exceeds the threshold would be able to access the bytes for the encrypted secrets but would still need the master password to decrypt the secrets.}

\paragraph{By using threshold signatures as a recovery mechanism we can \emph{distribute the trust} across multiple family members and provide redundancy in the case of deaths in the recovery circle.}

\paragraph{We will look at the problem of providing access to the master password to a recovery circle later.}

\subsection{Meta Data}

\paragraph{An attacker that acquires the encrypted vault should not be able to determine any information about the contents via meta data. The implication is that any indexing for search purposes would need to be performed client-side.}

\subsection{Self-hosted}

\paragraph{Our philosophy is sovereign ownership of assets and data so the program should be designed for self-hosting first but allow for an untrusted service provider to host the vaults for non-technical people that don't want the burden of managing a hosted service.}

\subsection{Cross-platform}

\paragraph{People should be free to change their computing platforms without worrying about losing access to their self-hosted secrets so the client software should run on all the major platforms. Linux, MacOS, Windows, iOS, Android and the Web.}

\subsection{Integrations}

\paragraph{Owners of vaults should be able to allow third-party applications to manage secrets to provide interoperability with third-party programs. The secrets stored by third-party applications must be isolated by namespace.}

\section{Components}

Use a standard server/client architecture to separate responsibilities:

\begin{itemize}
  \item Server manages authentication and authorization to encrypted vaults
  \item Client implementations authenticate to the server to retrieve encrypted vaults; decryption is always performed client-side
\end{itemize}

\section{Authentication}

\paragraph{Each vault has a corresponding encrypted authentication map that contains the public keys of clients that may access the vault. The authentication map must be loaded by the server so it can determine who is allowed access but it may only be modified by the vault owner.}

\paragraph{The authentication map must be encrypted to prevent an attacker from modifying the map to assign a public key allowed to authenticate.}

\paragraph{When the server starts each vault will be in a locked state and the vault owner must \emph{unlock} the authentication map using BLS Threshold Decryption\footnote{\href{https://en.wikipedia.org/wiki/BLS_digital_signature}{BLS Digital Signatures}} enabled by key shares distributed between the server and the owner. The server will then store the decrypted authentication map in memory and in collaboration with the owner can provide a secure mechanism to modify the in-memory authentication map as well as the encrypted authentication map.}

\paragraph{Once a server has \emph{unlocked} the authentication map for a vault clients can authenticate by signing a challenge which when verified corresponds to a public key in the authentication map. Upon successful authentication the server will issue a JWT\footnote{\href{https://en.wikipedia.org/wiki/JSON_Web_Token}{JSON Web Token}} that will allow a client to retrieve the encrypted contents of the vault.}

\section{Password Based Key Derivation Function}

\paragraph{People are not very good at generating entropy and in particular choosing strong passwords. Whilst we intend to provide excellent user interface tools to assist in generating strong passwords we also need to ensure that the encryption private key is computationally expensive to brute force attack.}

\paragraph{The user-supplied password is converted to a private key using the state of the art Argon2\footnote{\href{https://en.wikipedia.org/wiki/Argon2}{Argon2}} key derivation function and the generated salt is stored along with the vault so the same private key can be derived later. The result of the key derivation function is then hashed using Keccak256\footnote{\href{https://en.wikipedia.org/wiki/SHA-3}{SHA-3}} to get the 32 bytes we need for the symmetric key.}

\section{Diceware}

\paragraph{Diceware\footnote{\href{https://en.wikipedia.org/wiki/Diceware}{Diceware}} is a method for generating passphrases with strong entropy. The user interface should enforce using a passphrase with strong entropy, the suggested minimum is 6 words which corresponds to approximately 77 bits of entropy. The user should be able to refresh to generate a new random passphrase to see if they may find words that could be more memorable or to avoid words they dislike. Controls may be provided to allow generating stronger passphrases.}

\section{Audit Logs}

\paragraph{The server must implement audit logs so that in the case of a compromised signing key it would be possible to see the activity that occured during the period of the compromise.}

\paragraph{Audit logs must not contain any personal information or leak any meta data other than a timestamp and opaque identifiers. Log records contain the \emph{when}, \emph{what} and by \emph{whom} of an interaction with the server.}

\subsection{Log Records}

\paragraph{An audit log record may be 34, 50 or 66 bytes long depending upon the presence of associated data. When a log record does not have any associated data it will be 34 bytes and consist of a \emph{timestamp}, \emph{operation} and \emph{address}. The \emph{timestamp} tells auditors when an event happened; timestamps should be stored in UTC relative to the UNIX epoch. The \emph{operation} is a single byte and thus limited to 256 possible values, it indicates \emph{what} happened. The \emph{address} is a 20-byte address generated from a verifying key which tells us \emph{who} performed the operation.}

\paragraph{Before the \emph{timestamp}, \emph{operation} and \emph{address} is a single byte that contains bit flags for any data associated with the log record. The first bit indicates if any associated data is present, the second bit indicates that a vault identifier is associated with the log record and the third bit indicates that a secret identifier is associated with the log record; the remaining bits should not be used.}

\begin{itemize}
  \item Context data bit flags = 1 byte
  \item Timestamp seconds = 8 bytes
  \item Timestamp nanoseconds = 4 bytes
  \item Operation identifier = 1 byte
  \item Address = 20 bytes
  \item Context data = 16 | 32 bytes
\end{itemize}

\subsection{Log File}

\paragraph{If a server chooses to write audit log records to a file it is recommened that the file have a \emph{.dat} extension. The file must start with the identity bytes:}

\begin{verbatim}
0x53, 0x4F, 0x53, 0x41
\end{verbatim}

\section{Server}

\paragraph{The server must expose it's API\footnote{Application Programming Interface} over HTTPS to mitigate against MITM\footnote{\href{https://en.wikipedia.org/wiki/Man-in-the-middle_attack}{Man in the middle}} attacks.}

\subsection{Authentication \& Identity}

\paragraph{Authenticating to the server must be performed using an \emph{Authorization} header of the \emph{Bearer} type.}

\paragraph{The value of the header is a base64 encoded JSON document with \emph{r}, \emph{s} and \emph{v} fields which are a valid ECDSA\footnote{\href{https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm}{Elliptic Curve Digital Signature Algorithm}} \emph{recoverable signature}. The \emph{r} and \emph{s} values should be hex-encoded strings and the \emph{v} (or \emph{recovery identifier}) should be a number; it must be a normalized \emph{recovery identifier} with a value of either zero or one.}

\paragraph{The server must always use an address derived from the public key recovered from the signature to determine the identity of the client. In order to recover the public key a message must be known which for POST and PUT requests should be provided as the body. For other requests that do not support body data such as GET and DELETE the client must supply the message as base64 encoded JSON in the \emph{x-signed-message} header.}

\end{document}
