{"mappings":"umBAsBA,IAAAA,EACAC,mFArBA,IAAIC,EAAU,GAoBdF,EAlBA,SAAkBG,GAGhB,IAFA,IAAIC,EAAOC,OAAOD,KAAKD,GAEdG,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAC/BJ,EAAQE,EAAKE,IAAMH,EAAMC,EAAKE,KAelCL,EAXA,SAAiBO,GACf,IAAIC,EAAWP,EAAQM,GAEvB,GAAgB,MAAZC,EACF,MAAM,IAAIC,MAAM,oCAAsCF,GAGxD,OAAOC,wCClBT,IAAIE,4UAEJ,MAAMC,EAAO,IAAIC,MAAM,IAAIC,UAAKC,GAIhC,SAASC,EAAUC,GAAO,OAAOL,EAAKK,GAFtCL,EAAKM,UAAKH,EAAW,MAAM,GAAM,GAIjC,IAEII,EAFAC,EAAkB,EAGtB,SAASC,IAIL,OAHsC,IAAlCF,EAAmBG,aACnBH,EAAqB,IAAII,WAAWZ,EAAKa,OAAOC,SAE7CN,EAGX,MAAMO,EAAoB,IAAIC,YAAY,SAEpCC,EAAwD,mBAAjCF,EAAkBG,WACzC,SAAUC,EAAKC,GACjB,OAAOL,EAAkBG,WAAWC,EAAKC,IAEvC,SAAUD,EAAKC,GACjB,MAAMC,EAAMN,EAAkBO,OAAOH,GAErC,OADAC,EAAKG,IAAIF,GACF,CACHG,KAAML,EAAIvB,OACV6B,QAASJ,EAAIzB,SAIrB,SAAS8B,EAAkBP,EAAKQ,EAAQC,GAEpC,QAAgBxB,IAAZwB,EAAuB,CACvB,MAAMP,EAAMN,EAAkBO,OAAOH,GAC/BU,EAAMF,EAAON,EAAIzB,QAGvB,OAFAc,IAAkBoB,SAASD,EAAKA,EAAMR,EAAIzB,QAAQ2B,IAAIF,GACtDZ,EAAkBY,EAAIzB,OACfiC,EAGX,IAAIE,EAAMZ,EAAIvB,OACViC,EAAMF,EAAOI,GAEjB,MAAMC,EAAMtB,IAEZ,IAAIuB,EAAS,EAEb,KAAOA,EAASF,EAAKE,IAAU,CAC3B,MAAMC,EAAOf,EAAIgB,WAAWF,GAC5B,GAAIC,EAAO,IAAM,MACjBF,EAAIH,EAAMI,GAAUC,EAGxB,GAAID,IAAWF,EAAK,CACD,IAAXE,IACAd,EAAMA,EAAIiB,MAAMH,IAEpBJ,EAAMD,EAAQC,EAAKE,EAAKA,EAAME,EAAsB,EAAbd,EAAIvB,QAC3C,MAAMwB,EAAOV,IAAkBoB,SAASD,EAAMI,EAAQJ,EAAME,GAG5DE,GAFYhB,EAAaE,EAAKC,GAEhBK,QAIlB,OADAhB,EAAkBwB,EACXJ,EAGX,IAAIQ,EACJ,SAASC,IAIL,OAHsC,IAAlCD,EAAmB1B,aACnB0B,EAAqB,IAAIE,WAAWvC,EAAKa,OAAOC,SAE7CuB,EAGX,IAAIG,EAAYvC,EAAKL,OAQrB,SAAS6C,EAAWnC,GAChB,MAAMoC,EAAMrC,EAAUC,GAEtB,OATJ,SAAoBA,GACZA,EAAM,KACVL,EAAKK,GAAOkC,EACZA,EAAYlC,GAKZqC,CAAWrC,GACJoC,EAGX,MAAME,EAAoB,IAAIC,YAAY,QAAS,CAAEC,WAAW,EAAMC,OAAO,IAI7E,SAASC,EAAmBnB,EAAKE,GAC7B,OAAOa,EAAkBK,OAAOvC,IAAkBoB,SAASD,EAAKA,EAAME,IAG1E,SAASmB,EAAcC,GACfX,IAAcvC,EAAKL,QAAQK,EAAKM,KAAKN,EAAKL,OAAS,GACvD,MAAMU,EAAMkC,EAIZ,OAHAA,EAAYvC,EAAKK,GAEjBL,EAAKK,GAAO6C,EACL7C,EAIJ,SAAS8C,IACZpD,EAAKoD,QAGT,SAASC,EAAoBxB,EAAKE,GAC9B,OAAOrB,IAAkBoB,SAASD,EAAM,EAAGA,EAAM,EAAIE,GAOlD,SAASuB,EAAmBC,GAC/B,IACI,MAAMC,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAKsD,mBAAmBE,EAAQD,GAChC,IAAIG,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWkB,GAErB,OAAOlB,EAAWiB,GACrB,QACG1D,EAAKyD,gCAAgC,KAUtC,SAASG,EAAMC,GAClB,IACI,MAAML,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAK4D,MAAMJ,EAAQN,EAAcW,IACjC,IAAIH,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GACpCM,EAAKxB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWqB,GAErB,IAAIC,EAAKV,EAAoBK,EAAIC,GAAIvB,QAErC,OADApC,EAAKgE,gBAAgBN,EAAS,EAALC,GAClBI,EACV,QACG/D,EAAKyD,gCAAgC,KAI7C,SAASQ,EAAYC,EAAGC,GACpB,IACI,OAAOD,EAAEE,MAAMC,KAAMF,GACvB,MAAOG,GACLtE,EAAKuE,qBAAqBrB,EAAcoB,KAzEhD1B,EAAkBK,SA+EX,MAAMuB,EAETC,cAAc5C,GACV,MAAMsB,EAAMzD,OAAOgF,OAAOF,EAAOG,WAGjC,OAFAxB,EAAItB,IAAMA,EAEHsB,EAGXyB,qBACI,MAAM/C,EAAMwC,KAAKxC,IAGjB,OAFAwC,KAAKxC,IAAM,EAEJA,EAGXgD,OACI,MAAMhD,EAAMwC,KAAKO,qBACjB5E,EAAK8E,kBAAkBjD,GAK3BkD,cACI,MAAMrC,EAAM1C,EAAKgF,aACjB,OAAOR,EAAOS,OAAOvC,GAOzBwC,cAAcC,GACV,IACI,MAAM3B,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAKoF,qBAAqB5B,EAAQa,KAAKxC,IAAKqB,EAAciC,IAC1D,IAAIzB,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWkB,GAErB,OAAOlB,EAAWiB,GACrB,QACG1D,EAAKyD,gCAAgC,KAQ7C4B,wBAAwBF,GACpB,IACI,MAAM3B,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAKsF,+BAA+B9B,EAAQa,KAAKxC,IAAKqB,EAAciC,IACpE,IAAIzB,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWkB,GAErB,OAAOlB,EAAWiB,GACrB,QACG1D,EAAKyD,gCAAgC,KAO7C8B,0BACI,IACI,MAAM/B,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAKwF,+BAA+BhC,EAAQa,KAAKxC,KACjD,IAAI6B,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWkB,GAErB,OAAOlB,EAAWiB,GACrB,QACG1D,EAAKyD,gCAAgC,KAO7CgC,qBACI,IACI,MAAMjC,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAK0F,0BAA0BlC,EAAQa,KAAKxC,KAC5C,IAAI6B,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWkB,GAErB,OAAOlB,EAAWiB,GACrB,QACG1D,EAAKyD,gCAAgC,KAO7CkC,UACI3F,EAAK4F,eAAevB,KAAKxC,MAM1B,MAAMgE,EAETpB,cAAc5C,GACV,MAAMsB,EAAMzD,OAAOgF,OAAOmB,EAAUlB,WAGpC,OAFAxB,EAAItB,IAAMA,EAEHsB,EAGXyB,qBACI,MAAM/C,EAAMwC,KAAKxC,IAGjB,OAFAwC,KAAKxC,IAAM,EAEJA,EAGXgD,OACI,MAAMhD,EAAMwC,KAAKO,qBACjB5E,EAAK8F,qBAAqBjE,GAK9BkD,cACI,MAAMrC,EAAM1C,EAAK+F,gBACjB,OAAOF,EAAUZ,OAAOvC,GAS5BsD,aAAab,EAAYc,GACrB,IACI,MAAMzC,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAKkG,uBAAuB1C,EAAQa,KAAKxC,IAAKqB,EAAciC,GAAajC,EAAc+C,IACvF,IAAIvC,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWkB,GAErB,OAAOlB,EAAWiB,GACrB,QACG1D,EAAKyD,gCAAgC,KAQ7C0C,KAAKC,GACD,IACI,MAAM5C,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAKqG,eAAe7C,EAAQa,KAAKxC,IAAKqB,EAAckD,IACpD,IAAI1C,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWkB,GAErB,OAAOlB,EAAWiB,GACrB,QACG1D,EAAKyD,gCAAgC,MAO1C,MAAM6C,EAET7B,cAAc5C,GACV,MAAMsB,EAAMzD,OAAOgF,OAAO4B,EAAS3B,WAGnC,OAFAxB,EAAItB,IAAMA,EAEHsB,EAGXyB,qBACI,MAAM/C,EAAMwC,KAAKxC,IAGjB,OAFAwC,KAAKxC,IAAM,EAEJA,EAGXgD,OACI,MAAMhD,EAAMwC,KAAKO,qBACjB5E,EAAKuG,oBAAoB1E,GAK7BkD,cACI,MAAMrC,EAAM1C,EAAKwG,eACjB,OAAOF,EAASrB,OAAOvC,GAQ3B+D,WAAWC,EAAMC,EAAOC,GACpB,IACI,MAAMpD,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAK6G,oBAAoBrD,EAAQa,KAAKxC,IAAKqB,EAAcwD,GAAOxD,EAAcyD,GAAQzD,EAAc0D,IACpG,IAAIlD,EAAKpB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWiB,GAExB,QACG1D,EAAKyD,gCAAgC,KAO7CqD,aAAahG,GACT,IACI,MAAM0C,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAK+G,sBAAsBvD,EAAQa,KAAKxC,IAAKqB,EAAcpC,IAC3D,IAAI4C,EAAKpB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWiB,GAExB,QACG1D,EAAKyD,gCAAgC,KAO7CuD,eACI,IACI,MAAMxD,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAKiH,sBAAsBzD,EAAQa,KAAKxC,KACxC,IAAI6B,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWkB,GAErB,OAAOlB,EAAWiB,GACrB,QACG1D,EAAKyD,gCAAgC,KAO7C5D,KACI,IACI,MAAM2D,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAKkH,YAAY1D,EAAQa,KAAKxC,KAC9B,IAAI6B,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWkB,GAErB,OAAOlB,EAAWiB,GACrB,QACG1D,EAAKyD,gCAAgC,KAO7CiD,OACI,IACI,MAAMlD,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAKmH,cAAc3D,EAAQa,KAAKxC,KAChC,IAAI6B,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWkB,GAErB,OAAOlB,EAAWiB,GACrB,QACG1D,EAAKyD,gCAAgC,KAO7CkD,QACI,IACI,MAAMnD,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAKoH,eAAe5D,EAAQa,KAAKxC,KACjC,IAAI6B,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWkB,GAErB,OAAOlB,EAAWiB,GACrB,QACG1D,EAAKyD,gCAAgC,KAQ7CiB,OAAO2C,GACH,IACI,MAAM7D,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAKsH,gBAAgB9D,EAAQa,KAAKxC,IAAKqB,EAAcmE,IACrD,IAAI3D,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWkB,GAErB,OAAOlB,EAAWiB,GACrB,QACG1D,EAAKyD,gCAAgC,KAQ7CjC,KAAK3B,GACD,IACI,MAAM2D,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAKuH,cAAc/D,EAAQa,KAAKxC,IAAKqB,EAAcrD,IACnD,IAAI6D,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWkB,GAErB,OAAOlB,EAAWiB,GACrB,QACG1D,EAAKyD,gCAAgC,KAQ7C+D,OAAOH,GACH,IACI,MAAM7D,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAKyH,gBAAgBjE,EAAQa,KAAKxC,IAAKqB,EAAcmE,IACrD,IAAI3D,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWkB,GAErB,OAAOlB,EAAWiB,GACrB,QACG1D,EAAKyD,gCAAgC,KAQ7CiE,OAAO7H,GACH,IACI,MAAM2D,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAK2H,gBAAgBnE,EAAQa,KAAKxC,IAAKqB,EAAcrD,IACrD,IAAI6D,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWkB,GAErB,OAAOlB,EAAWiB,GACrB,QACG1D,EAAKyD,gCAAgC,KAQ7CmE,OAAOzC,GACH,IACI,MAAM3B,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAK6H,gBAAgBrE,EAAQa,KAAKxC,IAAKqB,EAAciC,IACrD,IAAIzB,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWkB,GAErB,OAAOlB,EAAWiB,GACrB,QACG1D,EAAKyD,gCAAgC,KAM7CqE,OACI9H,EAAK+H,cAAc1D,KAAKxC,KAM5Bf,SACI,IACI,MAAM0C,EAASxD,EAAKyD,iCAAgC,IACpDzD,EAAKgI,gBAAgBxE,EAAQa,KAAKxC,KAClC,IAAI6B,EAAKpB,IAAkBkB,EAAS,EAAI,GACpCG,EAAKrB,IAAkBkB,EAAS,EAAI,GACpCM,EAAKxB,IAAkBkB,EAAS,EAAI,GAExC,GADSlB,IAAkBkB,EAAS,EAAI,GAEpC,MAAMf,EAAWqB,GAErB,IAAIC,EAAKV,EAAoBK,EAAIC,GAAIvB,QAErC,OADApC,EAAKgE,gBAAgBN,EAAS,EAALC,GAClBI,EACV,QACG/D,EAAKyD,gCAAgC,MAoCjD,SAASwE,IACL,MAAMC,EAAU,CAChBA,IAAc,IAmJd,OAlJAA,EAAQC,IAAIC,2BAA6B,SAASC,EAAMC,GACpDC,QAAQC,IAAIxF,EAAmBqF,EAAMC,KAEzCJ,EAAQC,IAAIM,0BAA4B,SAASJ,EAAMC,GACnD,MAAMnF,EAAM9C,EAAUiI,GAEhBI,EAAOhH,EADDiH,KAAKC,eAAkBxI,IAAR+C,EAAoB,KAAOA,GAClBnD,EAAK6I,kBAAmB7I,EAAK8I,oBAC3DC,EAAOtI,EACb6B,IAAkB+F,EAAO,EAAI,GAAKU,EAClCzG,IAAkB+F,EAAO,EAAI,GAAKK,GAEtCR,EAAQC,IAAIa,2BAA6B,SAASX,GAC9C5F,EAAW4F,IAEfH,EAAQC,IAAIc,qBAAuB,SAASZ,EAAMC,GAE9C,OAAOpF,EADK,IAAInD,MAAMiD,EAAmBqF,EAAMC,MAGnDJ,EAAQC,IAAIe,sBAAwB,SAASb,EAAMC,GAE/C,OAAOpF,EADKyF,KAAKQ,MAAMnG,EAAmBqF,EAAMC,MAGpDJ,EAAQC,IAAIiB,2BAA6B,WAErC,OAAOlG,EADK,IAAInD,QAGpBmI,EAAQC,IAAIkB,6BAA+B,SAAShB,EAAMC,GACtD,MACMI,EAAOhH,EADDrB,EAAUiI,GAAMgB,MACQtJ,EAAK6I,kBAAmB7I,EAAK8I,oBAC3DC,EAAOtI,EACb6B,IAAkB+F,EAAO,EAAI,GAAKU,EAClCzG,IAAkB+F,EAAO,EAAI,GAAKK,GAEtCR,EAAQC,IAAIoB,6BAA+B,SAASlB,EAAMC,GACtD,IACIC,QAAQiB,MAAMxG,EAAmBqF,EAAMC,IAC1C,QACGtI,EAAKgE,gBAAgBqE,EAAMC,KAGnCJ,EAAQC,IAAIsB,sCAAwC,WAAa,OAAOxF,GAAY,SAAUoE,EAAMC,EAAMoB,GACtGrJ,EAAUgI,GAAMsB,eAAetG,EAAoBiF,EAAMoB,MAC1DE,YACH1B,EAAQC,IAAI0B,uCAAyC,WAAa,OAAO5F,GAAY,SAAUoE,EAAMC,GACjGjI,EAAUgI,GAAMyB,gBAAgBzJ,EAAUiI,MAC3CsB,YACH1B,EAAQC,IAAI4B,+BAAiC,SAAS1B,GAElD,OAAOnF,EADK7C,EAAUgI,GAAM2B,UAGhC9B,EAAQC,IAAI8B,qBAAuB,SAAS5B,GACxC,MAAM6B,EAAM7J,EAAUgI,GAEtB,MAD4B,iBAAT6B,GAA6B,OAARA,GAG5ChC,EAAQC,IAAIgC,gCAAkC,SAAS9B,GAEnD,OAAOnF,EADK7C,EAAUgI,GAAM+B,WAGhClC,EAAQC,IAAIkC,4BAA8B,SAAShC,GAE/C,OAAOnF,EADK7C,EAAUgI,GAAMiC,OAGhCpC,EAAQC,IAAIoC,qBAAuB,SAASlC,GAExC,MADwC,iBAArBhI,EAAUgI,IAGjCH,EAAQC,IAAIqC,mDAAqD,WAE7D,OAAOtH,EADKuH,IAGhBvC,EAAQC,IAAIuC,+BAAiC,WAAa,OAAOzG,GAAY,SAAUoE,EAAMC,EAAMoB,GAE/F,OAAOxG,EADK7C,EAAUgI,GAAMsC,QAAQ3H,EAAmBsF,EAAMoB,OAE9DE,YACH1B,EAAQC,IAAIyC,8BAAgC,SAASvC,GAEjD,OAAOnF,EADK7C,EAAUgI,GAAMwC,SAGhC3C,EAAQC,IAAI2C,gCAAkC,SAASzC,GAEnD,OAAOnF,EADK7C,EAAUgI,GAAM0C,WAGhC7C,EAAQC,IAAI6C,iCAAmC,SAAS3C,EAAMC,GAE1D,OAAOpF,EADK,IAAI+H,SAASjI,EAAmBqF,EAAMC,MAGtDJ,EAAQC,IAAI+C,4BAA8B,WAAa,OAAOjH,GAAY,SAAUoE,EAAMC,GAEtF,OAAOpF,EADK7C,EAAUgI,GAAM8C,KAAK9K,EAAUiI,OAE5CsB,YACH1B,EAAQC,IAAIiD,4BAA8B,SAAS/C,GAE/C,OAAOnF,EADK7C,EAAUgI,KAG1BH,EAAQC,IAAIkD,4BAA8B,WAAa,OAAOpH,GAAY,WAEtE,OAAOf,EADKoI,KAAKA,QAElB1B,YACH1B,EAAQC,IAAIoD,8BAAgC,WAAa,OAAOtH,GAAY,WAExE,OAAOf,EADKsI,OAAOA,UAEpB5B,YACH1B,EAAQC,IAAIsD,kCAAoC,WAAa,OAAOxH,GAAY,WAE5E,OAAOf,EADKwI,WAAWA,cAExB9B,YACH1B,EAAQC,IAAIwD,8BAAgC,WAAa,OAAO1H,GAAY,WAExE,OAAOf,EADK0I,EAAOC,UAEpBjC,YACH1B,EAAQC,IAAI2D,wBAA0B,SAASzD,GAE3C,YADgCjI,IAApBC,EAAUgI,IAG1BH,EAAQC,IAAI4D,8BAAgC,SAAS1D,GAEjD,OAAOnF,EADK7C,EAAUgI,GAAMvH,SAGhCoH,EAAQC,IAAI6D,2BAA6B,SAAS3D,GAE9C,OAAOnF,EADK,IAAItC,WAAWP,EAAUgI,MAGzCH,EAAQC,IAAI8D,2BAA6B,SAAS5D,EAAMC,EAAMoB,GAC1DrJ,EAAUgI,GAAM9G,IAAIlB,EAAUiI,GAAOoB,IAAS,IAElDxB,EAAQC,IAAI+D,8BAAgC,SAAS7D,GAEjD,OADYhI,EAAUgI,GAAMzI,QAGhCsI,EAAQC,IAAIgE,qCAAuC,SAAS9D,GAExD,OAAOnF,EADK,IAAItC,WAAWyH,IAAS,KAGxCH,EAAQC,IAAIiE,gCAAkC,SAAS/D,EAAMC,EAAMoB,GAE/D,OAAOxG,EADK7C,EAAUgI,GAAMvG,SAASwG,IAAS,EAAGoB,IAAS,KAG9DxB,EAAQC,IAAIkE,iBAAmB,SAAShE,EAAMC,GAC1C,MAAM,IAAIvI,MAAMiD,EAAmBqF,EAAMC,KAE7CJ,EAAQC,IAAImE,kBAAoB,WAE5B,OAAOpJ,EADKlD,EAAKa,SAIdqH,EAOX,SAASqE,EAAaC,EAAU/B,GAO5B,OANAzK,EAAOwM,EAASC,QAChBC,EAAKC,uBAAyBlC,EAC9BpI,EAAqB,IAAIE,WAAWvC,EAAKa,OAAOC,QAChDN,EAAqB,IAAII,WAAWZ,EAAKa,OAAOC,QAEhDd,EAAK4M,mBACE5M,EAGX,SAAS6M,EAASC,GACd,MAAM5E,EAAUD,IAIVwC,EAAS,IAAIsC,YAAYC,OAAOF,GAGtC,OAAOP,EAFU,IAAIQ,YAAYE,SAASxC,EAAQvC,GAEpBuC,GAGlCyC,eAAeR,EAAKS,QACK,IAAVA,IACPA,EAAK,IAAAC,IAAAC,EAAA,WAET,MAAMnF,EAAUD,KAEK,iBAAVkF,GAA0C,mBAAZG,SAA0BH,aAAiBG,SAA4B,mBAARF,KAAsBD,aAAiBC,OAC3ID,EAAQI,MAAMJ,IAKlB,MAAMX,SAAEA,EAAQ/B,OAAEA,SA5NtByC,eAAoBzC,EAAQvC,GACxB,GAAwB,mBAAbsF,UAA2B/C,aAAkB+C,SAAU,CAC9D,GAAgD,mBAArCT,YAAYU,qBACnB,IACI,aAAaV,YAAYU,qBAAqBhD,EAAQvC,GAExD,MAAO5D,GACL,GAA0C,oBAAtCmG,EAAOiD,QAAQC,IAAI,gBAInB,MAAMrJ,EAHNiE,QAAQqF,KAAK,oMAAqMtJ,GAQ9N,MAAMwI,QAAcrC,EAAOoD,cAC3B,aAAad,YAAYe,YAAYhB,EAAO5E,GAEzC,CACH,MAAMsE,QAAiBO,YAAYe,YAAYrD,EAAQvC,GAEvD,OAAIsE,aAAoBO,YAAYE,SACzB,CAAET,SAAAA,EAAU/B,OAAAA,GAGZ+B,GAkMoBuB,OAAWZ,EAAOjF,GAErD,OAAOqE,EAAaC,EAAU/B,OAIlCuD,EAAetB,uCC31BfjC,EAAAgC,QAAiBY,EAAA,SAAAY,aAA6C,SAAWZ,EAAA,SAAAa,QAA6C,8CC8CtH,IAAAC,+CA5CA,IAAIC,EAAY,GA6BhB,SAASC,EAAWC,GAClB,OAAQ,GAAKA,GAAKC,QAAO,+DAAiE,MAAQ,IAcpGJ,EA1CA,SAA4BtO,GAC1B,IAAI2O,EAAQJ,EAAUvO,GAOtB,OALK2O,IACHA,EAOJ,WACE,IACE,MAAM,IAAIzO,MACV,MAAO0O,GACP,IAAIC,GAAW,GAAKD,EAAInF,OAAOqF,MAAK,yDAEpC,GAAID,EAGF,OAAOL,EAAWK,EAAQ,IAI9B,MAAO,IApBGE,GACRR,EAAUvO,GAAM2O,GAGXA,MCZTnB,EAAA,SAAAwB,SAA8ClG,KAAKQ,MAAM,8GCAzD,IAAA2F,EAAAzB,EAAA,eC2NI0B,EAAUC,OAAQ,mBACXA,OAAA,sBAAMA,OAAA,0BAAEA,OAAA,oBAAM9E,GAAA,iBAAAA,GAAA,OAAAA,GAAA,mBAAAA,EAyErB+E,EAAgB,IAAAC,IAAA,UAvElB,WACOhF,GAAQiF,EAAAjF,IAAAA,EAAA6E,aAEd5L,GACD,MAAAiM,MAAAA,EAAAC,MAAAA,GAAA,IAAAC,eAiBA,OAPFC,EAAApM,EAAAiM,GAOa,CAC8BC,EACzC,CACMA,iBAKEG,sBAEkBA,EA0IO,GAAAC,OADVA,cArIiB,WAAGjB,GAAAW,EAAAX,IAAAkB,KAAAlB,aAEjCA,MAAUA,QAAEmB,EAqBtB,OArB0BA,EAAAnB,aAAAzO,MAAA,CACzB6P,SAAA,EACDpB,MAAY,CACNpI,QAAWoI,EAAOpI,QAMhBM,KAAA8H,EAAW9H,KAClB4C,MAAAkF,EAAAlF,QAUD,CAACsG,SAAO,EAAEpB,MAAAA,GACV,CAACmB,EAAS,KAGIE,YAAAF,GACX,GAAAA,EAAgBC,QAAC,MAAWlQ,OAASoQ,OAAQ,IAAiB/P,MAAjE4P,EAAAnB,MAAApI,SAAAuJ,EAAAnB,OACE,MAAKmB,EAAUnB,sBAkBXuB,EAAAC,EAAA1E,yBAEI,WAAY,SAAY2E,EAAIC,WAC5BA,EAAAC,KAAA,gBAEFtQ,EAAAuQ,KAAMA,EAAAC,KAAAA,GAAA3Q,OAAAoQ,OAAA,MACR,eAIQI,EAAAC,KAAAG,cAAA,IAAAC,IAAAC,qBAGJH,EAAMjO,MAAQ,GAAI,GAAAqO,QAAQ,CAAAtN,EAAIuN,IAAAvN,EAAcuN,SAE7CL,EAAAI,QAAA,CAAAtN,EAAAuN,IAAAvN,EAAAuN,cAEHN,OACE,QAjUVO,sBAoU2CvO,OAAK,GAAA,IAAAoO,EAAAN,EAAAC,KAAA3B,UAAG,YAEzC,QACFoC,EAAAD,EAAAvM,MAAAyM,EAAAP,GAEI,UAEF,YACF,CACE,MAAO9B,EAAA,IAAAmC,KAAAL,GAsKTnN,EArKDqL,EAAAoC,SAsKGd,OAAA3M,EAAA,MACI,IArKR,qBAAwB,CAAkB,MAAAiM,MAAAA,EAAAC,MAAAA,GAAA,IAAAC,eAC3CC,EAAAQ,EAAAV,GACeuB,EA4JpB,SAAAzN,EAAA2N,UACEC,EAA8BxP,IAAA4B,EAAA2N,GAE1B3N,EA9JC6N,CAAA5B,EAAA,CACQA,IAA4B,MAE/B,IAAC,UACEwB,OAAWxQ,EACf,cAAkC,mBAGhC,CACHoO,MAAAyC,EACDvB,CAAAA,GAAA,OAsJDvM,EAnJF+N,QAAQhD,QACP0C,GAAQO,OAAA3C,IAEd,CAEQA,MAAAA,EACAkB,CAAAA,GAA8B,MAG9B0B,MAAAC,IACH,MAAAC,EAAAC,GAAcC,EAA4BH,GAC/CrB,EAAAyB,YAAA/R,OAAAoQ,OAAApQ,OAAAoQ,OAAA,GAAAwB,GAAA,CAEezR,GAAAA,IACP0R,GACR,YAAAnB,IAGKJ,EAAU0B,oBACI,UAAAzB,GAEnB0B,EAAA3B,UASGA,EAAG5M,OAAC4M,EAAO5M,mBAMqBwO,aAJjBA,SAEF,kBAAP7M,YAAO2B,OAE8BkL,IAAAA,EAAAC,mBAKrCC,QAEI,MAAK,IAAA/R,MAAQ,yDAEIiQ,EAAAK,EAAA,GAAAZ,EAAA,qBAAQ,UAErB,IAAAsC,MAAAtC,EAAuB,OAC/BiB,QACkCsB,OAACC,EAAA,MAAA,IAC9BC,EAAgBlC,EAAA,CACvBI,KAAS,UACVC,KAAAA,EAAAE,KAAA4B,GAAAA,EAAAC,eAC0BhB,MAAI,KAAMO,EAAA3B,GAAGgC,GAAA,KAGxC,GAAA,SAAAtB,EAAA,oCAIA,MAAO2B,EAAAH,EAELlC,EAAA,CACMI,KAAJ,MACIC,KAAEA,EAAAE,KAAA4B,GAAAA,EAAAC,oBAAc5B,UAAO6B,EAACjB,KAAOkB,KAAAD,YAC9BrC,EAAA,IAEPK,EAEHK,SAGC6B,EAAU7B,EAAGC,GACb6B,EAAsBR,mBAMtB,OAAIE,EACKlC,EAAA,CAETI,KAAO,MACPC,KAAO,IAGHA,EACIK,GAA+BH,KAAA4B,GAAAA,EAAAC,aAGrC5D,MAAAA,GAEH+C,GAAAH,KAAAZ,UAEC+B,EAAAE,EAAAC,GACAF,EAAsCR,GACtC,MAAAW,EAAOtC,EAAAA,EAAAzQ,OAAA,MAGH+S,IAAAC,EAAA,OAAAV,EAAAlC,EAAA,CACAI,KAAM,kBAA6BI,MAGrC,SAAAmC,EACA,OAAKE,EAAe7C,EAAAK,EAAAjO,MAAA,GAAA,IACvB,MAAAkO,EAAAiB,GAAAuB,EAAAJ,GACA,OAAAR,EAAAlC,EAAA,CACII,KAAA,QACRC,KAAAA,EAAAE,KAAA4B,GAAAA,EAAAC,aAGa9B,aAAWA,GACxBiB,GAAAH,KAAAZ,IAGCuC,UAAeR,EAAGG,GACXF,EAAAR,GAAC,MAAU1B,EAAeiB,GAAAuB,EAAAJ,GAAC,OAAAR,EAAAlC,EAAA,CAAEI,KAAA,YAAkCC,KAAAA,EAAAE,KAAA4B,GAAAA,EAAAC,aACvE9B,aAAAA,GAEKiB,GAAAH,KAAAZ,MAGJ,OAAOwC,WAImDF,EAAAxC,GAC3D,MAAA2C,EAAA3C,EAAAC,IAAAiB,GAEe,MAAA,CAKdyB,EAAO1C,KAAA2C,GAAAA,EAAA,MATOC,EAWqCF,EAAA1C,KAAA2C,GAAAA,EAAA,KAV5ChT,MAAMyE,UAAQyO,OAAKhP,MAAA,GAAA+O,KADZ,IAAAA,QAefpC,EAAA,IAAAsC,iBAqBG7B,EAAahD,OACb,MAAA9H,EAAA4M,KAAArE,EAAA,GAAAqE,EAAAC,UAAA/E,GAAA,CACH,MAAAgF,EAAAjC,GAAA+B,EAAAG,UAAAjF,GAED,MAAS,CACC,CACN4B,KAAA,UACE1J,KAAOA,EACT8H,MAAAgF,GAEDjC,GAQD,MAAO,CACL,CACGnB,KAAA,MACD5B,MAAOA,KAIUb,IAAAa,IAAA,aAKnBgC,EAAchC,YAAG4B,UAAO,UACvB,OAAAnB,EAAAtB,IAAAa,EAAA9H,MAAAmJ,YAAArB,EAAAA,OACJ,IAAA,MAEQ,OAAAA,EAAAA,gBAKT0D,EAAAlC,EAAA0D,EAAA5C,2UD7hBAvI,QAAQC,IAAI,0BACN,uBAEEsG,EAAA6E,UACNpL,QAAQC,IAAI,gCACZ8C,KAAKmG,YAAY,CAAEmC,OAAO,IAJtB,GAONrE,EAAe,UAAET,EAAAxI,mBAAUwI,EAAAjJ,iBAAWiJ,EAAAtK,0BAAQsK,EAAAxL,yBAAoBwL,EAAAlL","sources":["node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","../pkg/wasm_bindings.js","node_modules/@parcel/runtime-js/lib/runtime-8be6da690dd5cf08.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-url.js","node_modules/@parcel/runtime-js/lib/runtime-2355aeed4e52e019.js","src/worker.ts","node_modules/comlink/src/comlink.ts"],"sourcesContent":["\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","\nlet wasm;\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedUint8Memory0;\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nconst cachedTextEncoder = new TextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedInt32Memory0;\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n/**\n*/\nexport function start() {\n    wasm.start();\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n* Generate a passphrase using the diceware module.\n* @param {number} words\n* @returns {any}\n*/\nexport function generatePassphrase(words) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.generatePassphrase(retptr, words);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Generate an encoded `Patch` from the supplied\n* list of change set (collection of `SyncEvent`).\n* @param {any} change_set\n* @returns {Uint8Array}\n*/\nexport function patch(change_set) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.patch(retptr, addHeapObject(change_set));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        var v0 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v0;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n* Store the state for a new account signup.\n*/\nexport class Signup {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Signup.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signup_free(ptr);\n    }\n    /**\n    * Create a signup for a new account.\n    */\n    constructor() {\n        const ret = wasm.signup_new();\n        return Signup.__wrap(ret);\n    }\n    /**\n    * Set the passphrase for the key generation.\n    * @param {any} passphrase\n    * @returns {any}\n    */\n    setPassphrase(passphrase) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signup_setPassphrase(retptr, this.ptr, addHeapObject(passphrase));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the passphrase for vault encryption.\n    * @param {any} passphrase\n    * @returns {any}\n    */\n    setEncryptionPassphrase(passphrase) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signup_setEncryptionPassphrase(retptr, this.ptr, addHeapObject(passphrase));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the passphrase for vault encryption.\n    * @returns {any}\n    */\n    getEncryptionPassphrase() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signup_getEncryptionPassphrase(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Generate an ECDSA private key and protect it with the given passphrase.\n    * @returns {any}\n    */\n    generatePrivateKey() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signup_generatePrivateKey(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Dispose of the internal state securely\n    * zeroing memory.\n    */\n    dispose() {\n        wasm.signup_dispose(this.ptr);\n    }\n}\n/**\n* Signer implementation for single-party ECDSA keys.\n*/\nexport class WebSigner {\n\n    static __wrap(ptr) {\n        const obj = Object.create(WebSigner.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_websigner_free(ptr);\n    }\n    /**\n    * Create a new web signer.\n    */\n    constructor() {\n        const ret = wasm.websigner_new();\n        return WebSigner.__wrap(ret);\n    }\n    /**\n    * Load a keystore into this web signer using the\n    * given decryption passphrase.\n    * @param {any} passphrase\n    * @param {any} keystore\n    * @returns {any}\n    */\n    loadKeystore(passphrase, keystore) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.websigner_loadKeystore(retptr, this.ptr, addHeapObject(passphrase), addHeapObject(keystore));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sign a message.\n    * @param {any} message\n    * @returns {any}\n    */\n    sign(message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.websigner_sign(retptr, this.ptr, addHeapObject(message));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Binding to the gatekeeper for a vault.\n*/\nexport class WebVault {\n\n    static __wrap(ptr) {\n        const obj = Object.create(WebVault.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_webvault_free(ptr);\n    }\n    /**\n    * Create an empty vault.\n    */\n    constructor() {\n        const ret = wasm.webvault_new();\n        return WebVault.__wrap(ret);\n    }\n    /**\n    * Initialize the vault with the given name, label and password.\n    * @param {any} name\n    * @param {any} label\n    * @param {any} password\n    */\n    initialize(name, label, password) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_initialize(retptr, this.ptr, addHeapObject(name), addHeapObject(label), addHeapObject(password));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Import a buffer as the vault.\n    * @param {any} buffer\n    */\n    importBuffer(buffer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_importBuffer(retptr, this.ptr, addHeapObject(buffer));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the meta data for the vault.\n    * @returns {any}\n    */\n    getVaultMeta() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_getVaultMeta(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the identifier for the vault.\n    * @returns {any}\n    */\n    id() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_id(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the public name for the vault.\n    * @returns {any}\n    */\n    name() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_name(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the private label for the vault.\n    * @returns {any}\n    */\n    label() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_label(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create a new secret.\n    * @param {any} request\n    * @returns {any}\n    */\n    create(request) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_create(retptr, this.ptr, addHeapObject(request));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a secret from the vault.\n    * @param {any} id\n    * @returns {any}\n    */\n    read(id) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_read(retptr, this.ptr, addHeapObject(id));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Update a new secret.\n    * @param {any} request\n    * @returns {any}\n    */\n    update(request) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_update(retptr, this.ptr, addHeapObject(request));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Delete a secret from the vault.\n    * @param {any} id\n    * @returns {any}\n    */\n    delete(id) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_delete(retptr, this.ptr, addHeapObject(id));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Unlock the vault.\n    * @param {any} passphrase\n    * @returns {any}\n    */\n    unlock(passphrase) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_unlock(retptr, this.ptr, addHeapObject(passphrase));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Lock the vault.\n    */\n    lock() {\n        wasm.webvault_lock(this.ptr);\n    }\n    /**\n    * Get a buffer of the encoded vault.\n    * @returns {Uint8Array}\n    */\n    buffer() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_buffer(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nasync function load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction getImports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_log_3ce8f72240c791d0 = function(arg0, arg1) {\n        console.log(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_json_serialize = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = JSON.stringify(obj === undefined ? null : obj);\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_json_parse = function(arg0, arg1) {\n        const ret = JSON.parse(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_693216e109162396 = function() {\n        const ret = new Error();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stack_0ddaca5d1abfb52f = function(arg0, arg1) {\n        const ret = getObject(arg1).stack;\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_error_09919627ac0992f5 = function(arg0, arg1) {\n        try {\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(arg0, arg1);\n        }\n    };\n    imports.wbg.__wbg_randomFillSync_378e02b85af41ab6 = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_getRandomValues_99bbe8a65f4aef87 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_process_5729605ce9d34ea8 = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbg_versions_531e16e1a776ee97 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_18b58a160b60d170 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbg_static_accessor_NODE_MODULE_bdc5ca9096c68aeb = function() {\n        const ret = module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_edfaedd93e302925 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_crypto_2bc4d5b05161de5b = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_msCrypto_d003eebe62c636a9 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newnoargs_f579424187aa1717 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_89558c3e96703ca1 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_self_e23d74ae45fb17d1 = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_b4be7f48b24ac56e = function() { return handleError(function () {\n        const ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_d61b1f48a57191ae = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_e7669da72fd7f239 = function() { return handleError(function () {\n        const ret = global.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbg_buffer_5e74a88a1424a2e0 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_e3b800e570795b3c = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_5b8081e9d002f0df = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_length_30803400a8f15c59 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_newwithlength_5f4ce114a24dfe1e = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_subarray_a68f835ca2af506f = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n\n    return imports;\n}\n\nfunction initMemory(imports, maybe_memory) {\n\n}\n\nfunction finalizeInit(instance, module) {\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(bytes) {\n    const imports = getImports();\n\n    initMemory(imports);\n\n    const module = new WebAssembly.Module(bytes);\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return finalizeInit(instance, module);\n}\n\nasync function init(input) {\n    if (typeof input === 'undefined') {\n        input = new URL('wasm_bindings_bg.wasm', import.meta.url);\n    }\n    const imports = getImports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    initMemory(imports);\n\n    const { instance, module } = await load(await input, imports);\n\n    return finalizeInit(instance, module);\n}\n\nexport { initSync }\nexport default init;\n","module.exports = require('./helpers/bundle-url').getBundleURL('2WX22') + require('./helpers/bundle-manifest').resolve(\"8mXX7\");","\"use strict\";\n\nvar bundleURL = {};\n\nfunction getBundleURLCached(id) {\n  var value = bundleURL[id];\n\n  if (!value) {\n    value = getBundleURL();\n    bundleURL[id] = value;\n  }\n\n  return value;\n}\n\nfunction getBundleURL() {\n  try {\n    throw new Error();\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp|(chrome|moz)-extension):\\/\\/[^)\\n]+/g);\n\n    if (matches) {\n      // The first two stack frames will be this function and getBundleURLCached.\n      // Use the 3rd one, which will be a runtime in the original bundle.\n      return getBaseURL(matches[2]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp|(chrome|moz)-extension):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\n\n\nfunction getOrigin(url) {\n  var matches = ('' + url).match(/(https?|file|ftp|(chrome|moz)-extension):\\/\\/[^/]+/);\n\n  if (!matches) {\n    throw new Error('Origin not found');\n  }\n\n  return matches[0];\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"2WX22\\\":\\\"worker.84bc89da.js\\\",\\\"8mXX7\\\":\\\"wasm_bindings_bg.e2396f97.wasm\\\"}\"));","import init, {\n  WebVault,\n  WebSigner,\n  Signup,\n  generatePassphrase,\n  patch,\n} from \"@saveoursecrets/wasm-bindings\";\nimport * as Comlink from \"comlink\";\n\n//export { WebVault, generatePassphrase } from \"sos-wasm\";\n\nconsole.log(\"WORKER IS INITIALIZING\");\nvoid (async function () {\n  // Requires top-level await experiment\n  await init();\n  console.log(\"Worker finished initializing\");\n  self.postMessage({ ready: true });\n})();\n\nComlink.expose({ WebVault, WebSigner, Signup, generatePassphrase, patch });\n","/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n} from \"./protocol\";\nexport { Endpoint };\n\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\n\nconst throwMarker = Symbol(\"Comlink.thrown\");\n\n/**\n * Interface of values that were marked to be proxied with `comlink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, comlink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : Promisify<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked\n  ? Local<T>\n  : Unpromisify<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Comlink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special comlink methods available on each proxy returned by `Comlink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => void;\n}\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Comlink.wrap()` or `Comlink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => Promisify<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): Promisify<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special comlink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Expresses that a type can be either a sync or async.\n */\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, comlink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<Unpromisify<TInstance>>>;\n        }\n      : unknown);\n\nconst isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value\n      );\n    }\n    throw serialized.value;\n  },\n};\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>([\n  [\"proxy\", proxyTransferHandler],\n  [\"throw\", throwTransferHandler],\n]);\n\nexport function expose(obj: any, ep: Endpoint = self as any) {\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    const { id, type, path } = {\n      path: [] as string[],\n      ...(ev.data as Message),\n    };\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n      switch (type) {\n        case MessageType.GET:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case MessageType.SET:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case MessageType.APPLY:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case MessageType.CONSTRUCT:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case MessageType.ENDPOINT:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case MessageType.RELEASE:\n          {\n            returnValue = undefined;\n          }\n          break;\n        default:\n          return;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    Promise.resolve(returnValue)\n      .catch((value) => {\n        return { value, [throwMarker]: 0 };\n      })\n      .then((returnValue) => {\n        const [wireValue, transferables] = toWireValue(returnValue);\n        ep.postMessage({ ...wireValue, id }, transferables);\n        if (type === MessageType.RELEASE) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback as any);\n          closeEndPoint(ep);\n        }\n      });\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  return createProxy<T>(ep, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction createProxy<T>(\n  ep: Endpoint,\n  path: (string | number | symbol)[] = [],\n  target: object = function () {}\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          return requestResponseMessage(ep, {\n            type: MessageType.RELEASE,\n            path: path.map((p) => p.toString()),\n          }).then(() => {\n            closeEndPoint(ep);\n            isProxyReleased = true;\n          });\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy };\n        }\n        const r = requestResponseMessage(ep, {\n          type: MessageType.GET,\n          path: path.map((p) => p.toString()),\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously \\_()_/\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables\n      ).then(fromWireValue) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT,\n        }).then(fromWireValue);\n      }\n      // We just pretend that `bind()` didnt happen.\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.APPLY,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n  });\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport function proxy<T>(obj: T): T & ProxyMarked {\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = self,\n  targetOrigin = \"*\"\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: WireValueType.HANDLER,\n          name,\n          value: serializedValue,\n        },\n        transferables,\n      ];\n    }\n  }\n  return [\n    {\n      type: WireValueType.RAW,\n      value,\n    },\n    transferCache.get(value) || [],\n  ];\n}\n\nfunction fromWireValue(value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[]\n): Promise<WireValue> {\n  return new Promise((resolve) => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n      ep.removeEventListener(\"message\", l as any);\n      resolve(ev.data);\n    } as any);\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage({ id, ...msg }, transfers);\n  });\n}\n\nfunction generateUUID(): string {\n  return new Array(4)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n    .join(\"-\");\n}\n"],"names":["$8831245f07480bee$export$6503ec6e8aabbaf","$8831245f07480bee$export$f7ad0328861e2f03","$8831245f07480bee$var$mapping","pairs","keys","Object","i","length","id","resolved","Error","wasm","heap","Array","fill","undefined","getObject","idx","push","cachedUint8Memory0","WASM_VECTOR_LEN","getUint8Memory0","byteLength","Uint8Array","memory","buffer","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","ptr","subarray","len","mem","offset","code","charCodeAt","slice","cachedInt32Memory0","getInt32Memory0","Int32Array","heap_next","takeObject","ret","dropObject","cachedTextDecoder","TextDecoder","ignoreBOM","fatal","getStringFromWasm0","decode","addHeapObject","obj","start","getArrayU8FromWasm0","generatePassphrase","words","retptr","__wbindgen_add_to_stack_pointer","r0","r1","patch","change_set","r2","v0","__wbindgen_free","handleError","f","args","apply","this","e","__wbindgen_exn_store","Signup","static","create","prototype","__destroy_into_raw","free","__wbg_signup_free","constructor","signup_new","__wrap","setPassphrase","passphrase","signup_setPassphrase","setEncryptionPassphrase","signup_setEncryptionPassphrase","getEncryptionPassphrase","signup_getEncryptionPassphrase","generatePrivateKey","signup_generatePrivateKey","dispose","signup_dispose","WebSigner","__wbg_websigner_free","websigner_new","loadKeystore","keystore","websigner_loadKeystore","sign","message","websigner_sign","WebVault","__wbg_webvault_free","webvault_new","initialize","name","label","password","webvault_initialize","importBuffer","webvault_importBuffer","getVaultMeta","webvault_getVaultMeta","webvault_id","webvault_name","webvault_label","request","webvault_create","webvault_read","update","webvault_update","delete","webvault_delete","unlock","webvault_unlock","lock","webvault_lock","webvault_buffer","getImports","imports","wbg","__wbg_log_3ce8f72240c791d0","arg0","arg1","console","log","__wbindgen_json_serialize","ptr0","JSON","stringify","__wbindgen_malloc","__wbindgen_realloc","len0","__wbindgen_object_drop_ref","__wbindgen_error_new","__wbindgen_json_parse","parse","__wbg_new_693216e109162396","__wbg_stack_0ddaca5d1abfb52f","stack","__wbg_error_09919627ac0992f5","error","__wbg_randomFillSync_378e02b85af41ab6","arg2","randomFillSync","arguments","__wbg_getRandomValues_99bbe8a65f4aef87","getRandomValues","__wbg_process_5729605ce9d34ea8","process","__wbindgen_is_object","val","__wbg_versions_531e16e1a776ee97","versions","__wbg_node_18b58a160b60d170","node","__wbindgen_is_string","__wbg_static_accessor_NODE_MODULE_bdc5ca9096c68aeb","module","__wbg_require_edfaedd93e302925","require","__wbg_crypto_2bc4d5b05161de5b","crypto","__wbg_msCrypto_d003eebe62c636a9","msCrypto","__wbg_newnoargs_f579424187aa1717","Function","__wbg_call_89558c3e96703ca1","call","__wbindgen_object_clone_ref","__wbg_self_e23d74ae45fb17d1","self","__wbg_window_b4be7f48b24ac56e","window","__wbg_globalThis_d61b1f48a57191ae","globalThis","__wbg_global_e7669da72fd7f239","$parcel$global","global","__wbindgen_is_undefined","__wbg_buffer_5e74a88a1424a2e0","__wbg_new_e3b800e570795b3c","__wbg_set_5b8081e9d002f0df","__wbg_length_30803400a8f15c59","__wbg_newwithlength_5f4ce114a24dfe1e","__wbg_subarray_a68f835ca2af506f","__wbindgen_throw","__wbindgen_memory","finalizeInit","instance","exports","init","__wbindgen_wasm_module","__wbindgen_start","initSync","bytes","WebAssembly","Module","Instance","async","input","URL","parcelRequire","Request","fetch","Response","instantiateStreaming","headers","get","warn","arrayBuffer","instantiate","load","$350f69505bb8016f$export$2e2bcd8739ae039","getBundleURL","resolve","$01a32f7bf710fe19$export$bdfd709ae4826697","$01a32f7bf710fe19$var$bundleURL","$01a32f7bf710fe19$var$getBaseURL","url","replace","value","err","matches","match","$01a32f7bf710fe19$var$getBundleURL","register","$4yras","$9d65ffd50b68f22a$export$be5234c0b764b6e0","Symbol","$9d65ffd50b68f22a$export$ab8f1c00731ee83e","Map","$9d65ffd50b68f22a$var$isObject","port1","port2","MessageChannel","$9d65ffd50b68f22a$export$9b7f6e342a8cbd38","port","target","$9d65ffd50b68f22a$var$throwMarker","serialized","isError","deserialize","assign","obj1","ep","callback","ev","data","type","path","argumentList","map","$9d65ffd50b68f22a$var$fromWireValue","reduce","prop","rawValue","returnValue1","parent","transfers","$9d65ffd50b68f22a$var$transferCache","$9d65ffd50b68f22a$export$c9b234447cf4ef7c","value1","Promise","catch","then","returnValue","wireValue","transferables","$9d65ffd50b68f22a$var$toWireValue","postMessage","removeEventListener","$9d65ffd50b68f22a$var$closeEndPoint","endpoint","close","isReleased","Proxy","isProxyReleased","$9d65ffd50b68f22a$export$89981d4b8d9f48aa","$9d65ffd50b68f22a$var$requestResponseMessage","p","toString","r","bind","_target","$9d65ffd50b68f22a$var$throwIfProxyReleased","_thisArg","rawArgumentList","last","$9d65ffd50b68f22a$export$39fb953702b7fcd7","$9d65ffd50b68f22a$var$createProxy","$9d65ffd50b68f22a$var$processArguments","construct","$9d65ffd50b68f22a$export$923f96dd5afa9ce6","processed","v","arr","concat","WeakMap","handler","canHandle","serializedValue","serialize","msg","default","ready"],"version":3,"file":"worker.84bc89da.js.map"}