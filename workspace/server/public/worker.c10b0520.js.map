{"mappings":"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","sources":["../workspace/wasm/pkg/sos_wasm.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-url.js","node_modules/@parcel/runtime-js/lib/runtime-19b306a66473ce85.js","node_modules/@parcel/runtime-js/lib/runtime-a62ae306be98bff3.js","node_modules/comlink/src/comlink.ts","src/worker.ts"],"sourcesContent":["\nlet wasm;\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nconst cachedTextEncoder = new TextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n/**\n*/\nexport function start() {\n    wasm.start();\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n* Generate a passphrase using the diceware module.\n* @param {number} words\n* @returns {any}\n*/\nexport function generatePassphrase(words) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.generatePassphrase(retptr, words);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n* Store the state for a new account signup.\n*/\nexport class Signup {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Signup.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signup_free(ptr);\n    }\n    /**\n    * Create a signup for a new account.\n    */\n    constructor() {\n        const ret = wasm.signup_new();\n        return Signup.__wrap(ret);\n    }\n    /**\n    * Set the passphrase for the key generation.\n    * @param {any} passphrase\n    * @returns {any}\n    */\n    setPassphrase(passphrase) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signup_setPassphrase(retptr, this.ptr, addHeapObject(passphrase));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the passphrase for vault encryption.\n    * @param {any} passphrase\n    * @returns {any}\n    */\n    setEncryptionPassphrase(passphrase) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signup_setEncryptionPassphrase(retptr, this.ptr, addHeapObject(passphrase));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the passphrase for vault encryption.\n    * @returns {any}\n    */\n    getEncryptionPassphrase() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signup_getEncryptionPassphrase(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Generate an ECDSA private key and protect it with the given passphrase.\n    * @returns {any}\n    */\n    generatePrivateKey() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signup_generatePrivateKey(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Dispose of the internal state securely\n    * zeroing memory.\n    */\n    dispose() {\n        wasm.signup_dispose(this.ptr);\n    }\n}\n/**\n* Signer implementation for single-party ECDSA keys.\n*/\nexport class WebSigner {\n\n    static __wrap(ptr) {\n        const obj = Object.create(WebSigner.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_websigner_free(ptr);\n    }\n    /**\n    * Create a new web signer.\n    */\n    constructor() {\n        const ret = wasm.websigner_new();\n        return WebSigner.__wrap(ret);\n    }\n    /**\n    * Load a keystore into this web signer using the\n    * given decryption passphrase.\n    * @param {any} passphrase\n    * @param {any} keystore\n    * @returns {any}\n    */\n    loadKeystore(passphrase, keystore) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.websigner_loadKeystore(retptr, this.ptr, addHeapObject(passphrase), addHeapObject(keystore));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sign a message.\n    * @param {any} message\n    * @returns {any}\n    */\n    sign(message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.websigner_sign(retptr, this.ptr, addHeapObject(message));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Binding to the gatekeeper for a vault.\n*/\nexport class WebVault {\n\n    static __wrap(ptr) {\n        const obj = Object.create(WebVault.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_webvault_free(ptr);\n    }\n    /**\n    * Create an empty vault.\n    */\n    constructor() {\n        const ret = wasm.webvault_new();\n        return WebVault.__wrap(ret);\n    }\n    /**\n    * Initialize the vault with the given name, label and password.\n    * @param {any} name\n    * @param {any} label\n    * @param {any} password\n    */\n    initialize(name, label, password) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_initialize(retptr, this.ptr, addHeapObject(name), addHeapObject(label), addHeapObject(password));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Import a buffer as the vault.\n    * @param {any} buffer\n    */\n    importBuffer(buffer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_importBuffer(retptr, this.ptr, addHeapObject(buffer));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the meta data for the vault.\n    * @returns {any}\n    */\n    getVaultMeta() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_getVaultMeta(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the identifier for the vault.\n    * @returns {any}\n    */\n    id() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_id(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the public name for the vault.\n    * @returns {any}\n    */\n    name() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_name(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the private label for the vault.\n    * @returns {any}\n    */\n    label() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_label(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create a new secret.\n    * @param {any} request\n    * @returns {any}\n    */\n    create(request) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_create(retptr, this.ptr, addHeapObject(request));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a secret from the vault.\n    * @param {any} uuid\n    * @returns {any}\n    */\n    read(uuid) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_read(retptr, this.ptr, addHeapObject(uuid));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Update a new secret.\n    * @param {any} request\n    */\n    update(request) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_update(retptr, this.ptr, addHeapObject(request));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Delete a secret from the vault.\n    * @param {any} uuid\n    * @returns {any}\n    */\n    delete(uuid) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_delete(retptr, this.ptr, addHeapObject(uuid));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Unlock the vault.\n    * @param {any} passphrase\n    * @returns {any}\n    */\n    unlock(passphrase) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_unlock(retptr, this.ptr, addHeapObject(passphrase));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Lock the vault.\n    */\n    lock() {\n        wasm.webvault_lock(this.ptr);\n    }\n    /**\n    * Get a buffer of the encoded vault.\n    * @returns {Uint8Array}\n    */\n    buffer() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webvault_buffer(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nasync function load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nasync function init(input) {\n    if (typeof input === 'undefined') {\n        input = new URL('sos_wasm_bg.wasm', import.meta.url);\n    }\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_log_7b91984099667bb9 = function(arg0, arg1) {\n        console.log(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_json_serialize = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = JSON.stringify(obj === undefined ? null : obj);\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_json_parse = function(arg0, arg1) {\n        const ret = JSON.parse(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_693216e109162396 = function() {\n        const ret = new Error();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stack_0ddaca5d1abfb52f = function(arg0, arg1) {\n        const ret = getObject(arg1).stack;\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_error_09919627ac0992f5 = function(arg0, arg1) {\n        try {\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(arg0, arg1);\n        }\n    };\n    imports.wbg.__wbg_getRandomValues_99bbe8a65f4aef87 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_randomFillSync_378e02b85af41ab6 = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_process_5729605ce9d34ea8 = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbg_versions_531e16e1a776ee97 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_18b58a160b60d170 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbg_static_accessor_NODE_MODULE_bdc5ca9096c68aeb = function() {\n        const ret = module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_edfaedd93e302925 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_crypto_2bc4d5b05161de5b = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_msCrypto_d003eebe62c636a9 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newnoargs_f579424187aa1717 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_89558c3e96703ca1 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_self_e23d74ae45fb17d1 = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_b4be7f48b24ac56e = function() { return handleError(function () {\n        const ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_d61b1f48a57191ae = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_e7669da72fd7f239 = function() { return handleError(function () {\n        const ret = global.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbg_buffer_5e74a88a1424a2e0 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_e3b800e570795b3c = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_5b8081e9d002f0df = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_length_30803400a8f15c59 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_newwithlength_5f4ce114a24dfe1e = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_subarray_a68f835ca2af506f = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n\n\n    const { instance, module } = await load(await input, imports);\n\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nexport default init;\n\n","\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","\"use strict\";\n\nvar bundleURL = {};\n\nfunction getBundleURLCached(id) {\n  var value = bundleURL[id];\n\n  if (!value) {\n    value = getBundleURL();\n    bundleURL[id] = value;\n  }\n\n  return value;\n}\n\nfunction getBundleURL() {\n  try {\n    throw new Error();\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp):\\/\\/[^)\\n]+/g);\n\n    if (matches) {\n      // The first two stack frames will be this function and getBundleURLCached.\n      // Use the 3rd one, which will be a runtime in the original bundle.\n      return getBaseURL(matches[2]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\n\n\nfunction getOrigin(url) {\n  var matches = ('' + url).match(/(https?|file|ftp):\\/\\/[^/]+/);\n\n  if (!matches) {\n    throw new Error('Origin not found');\n  }\n\n  return matches[0];\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"2WX22\\\":\\\"worker.c10b0520.js\\\",\\\"6DeOB\\\":\\\"sos_wasm_bg.3852e407.wasm\\\"}\"));","module.exports = require('./helpers/bundle-url').getBundleURL('2WX22') + require('./helpers/bundle-manifest').resolve(\"6DeOB\");","/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n} from \"./protocol\";\nexport { Endpoint };\n\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\n\nconst throwMarker = Symbol(\"Comlink.thrown\");\n\n/**\n * Interface of values that were marked to be proxied with `comlink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, comlink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : Promisify<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked\n  ? Local<T>\n  : Unpromisify<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Comlink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special comlink methods available on each proxy returned by `Comlink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => void;\n}\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Comlink.wrap()` or `Comlink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => Promisify<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): Promisify<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special comlink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Expresses that a type can be either a sync or async.\n */\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, comlink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<Unpromisify<TInstance>>>;\n        }\n      : unknown);\n\nconst isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value\n      );\n    }\n    throw serialized.value;\n  },\n};\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>([\n  [\"proxy\", proxyTransferHandler],\n  [\"throw\", throwTransferHandler],\n]);\n\nexport function expose(obj: any, ep: Endpoint = self as any) {\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    const { id, type, path } = {\n      path: [] as string[],\n      ...(ev.data as Message),\n    };\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n      switch (type) {\n        case MessageType.GET:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case MessageType.SET:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case MessageType.APPLY:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case MessageType.CONSTRUCT:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case MessageType.ENDPOINT:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case MessageType.RELEASE:\n          {\n            returnValue = undefined;\n          }\n          break;\n        default:\n          return;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    Promise.resolve(returnValue)\n      .catch((value) => {\n        return { value, [throwMarker]: 0 };\n      })\n      .then((returnValue) => {\n        const [wireValue, transferables] = toWireValue(returnValue);\n        ep.postMessage({ ...wireValue, id }, transferables);\n        if (type === MessageType.RELEASE) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback as any);\n          closeEndPoint(ep);\n        }\n      });\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  return createProxy<T>(ep, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction createProxy<T>(\n  ep: Endpoint,\n  path: (string | number | symbol)[] = [],\n  target: object = function () {}\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          return requestResponseMessage(ep, {\n            type: MessageType.RELEASE,\n            path: path.map((p) => p.toString()),\n          }).then(() => {\n            closeEndPoint(ep);\n            isProxyReleased = true;\n          });\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy };\n        }\n        const r = requestResponseMessage(ep, {\n          type: MessageType.GET,\n          path: path.map((p) => p.toString()),\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously \\_()_/\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables\n      ).then(fromWireValue) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT,\n        }).then(fromWireValue);\n      }\n      // We just pretend that `bind()` didnt happen.\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.APPLY,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n  });\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport function proxy<T>(obj: T): T & ProxyMarked {\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = self,\n  targetOrigin = \"*\"\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: WireValueType.HANDLER,\n          name,\n          value: serializedValue,\n        },\n        transferables,\n      ];\n    }\n  }\n  return [\n    {\n      type: WireValueType.RAW,\n      value,\n    },\n    transferCache.get(value) || [],\n  ];\n}\n\nfunction fromWireValue(value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[]\n): Promise<WireValue> {\n  return new Promise((resolve) => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n      ep.removeEventListener(\"message\", l as any);\n      resolve(ev.data);\n    } as any);\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage({ id, ...msg }, transfers);\n  });\n}\n\nfunction generateUUID(): string {\n  return new Array(4)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n    .join(\"-\");\n}\n","import init, {\n  WebVault,\n  WebSigner,\n  Signup,\n  generatePassphrase,\n} from \"sos-wasm\";\nimport * as Comlink from \"comlink\";\n\n//export { WebVault, generatePassphrase } from \"sos-wasm\";\n\nconsole.log(\"WORKER IS INITIALIZING\");\nvoid (async function () {\n  // Requires top-level await experiment\n  await init();\n  console.log(\"Worker finished initializing\");\n  self.postMessage({ ready: true });\n})();\n\nComlink.expose({ WebVault, WebSigner, Signup, generatePassphrase });\n"],"names":["$4ce57fe94e553770$var$wasm","$8831245f07480bee$export$6503ec6e8aabbaf","$8831245f07480bee$export$f7ad0328861e2f03","$8831245f07480bee$var$mapping","pairs","keys","Object","i","length","id","resolved","Error","$01a32f7bf710fe19$export$bdfd709ae4826697","$01a32f7bf710fe19$var$bundleURL","$01a32f7bf710fe19$var$getBaseURL","url","replace","value","err","matches","stack","match","$01a32f7bf710fe19$var$getBundleURL","parcelRequire","register","JSON","parse","$4ce57fe94e553770$var$heap","Array","fill","undefined","$4ce57fe94e553770$var$getObject","idx","push","$4ce57fe94e553770$var$WASM_VECTOR_LEN","$4ce57fe94e553770$var$cachegetUint8Memory0","$4ce57fe94e553770$var$getUint8Memory0","buffer","memory","Uint8Array","$4ce57fe94e553770$var$cachedTextEncoder","TextEncoder","$4ce57fe94e553770$var$encodeString","encodeInto","arg","view","buf","encode","set","read","written","$4ce57fe94e553770$var$passStringToWasm0","malloc","realloc","ptr","subarray","len","mem","offset","code","charCodeAt","slice","$4ce57fe94e553770$var$cachegetInt32Memory0","$4ce57fe94e553770$var$getInt32Memory0","Int32Array","$4ce57fe94e553770$var$heap_next","$4ce57fe94e553770$var$takeObject","ret","$4ce57fe94e553770$var$dropObject","$4ce57fe94e553770$var$cachedTextDecoder","TextDecoder","ignoreBOM","fatal","$4ce57fe94e553770$var$getStringFromWasm0","decode","$4ce57fe94e553770$var$addHeapObject","obj","$4ce57fe94e553770$var$getArrayU8FromWasm0","$4ce57fe94e553770$var$handleError","f","args","apply","this","e","__wbindgen_exn_store","$4ce57fe94e553770$export$89200835fb4edfb9","static","create","prototype","__destroy_into_raw","free","__wbg_signup_free","constructor","signup_new","__wrap","setPassphrase","passphrase","retptr","__wbindgen_add_to_stack_pointer","signup_setPassphrase","r0","r1","setEncryptionPassphrase","signup_setEncryptionPassphrase","getEncryptionPassphrase","signup_getEncryptionPassphrase","generatePrivateKey","signup_generatePrivateKey","dispose","signup_dispose","$4ce57fe94e553770$export$93b9eb552fc5e245","__wbg_websigner_free","websigner_new","loadKeystore","keystore","websigner_loadKeystore","sign","message","websigner_sign","$4ce57fe94e553770$export$5d0716cc6c705ff6","__wbg_webvault_free","webvault_new","initialize","name","label","password","webvault_initialize","importBuffer","webvault_importBuffer","getVaultMeta","webvault_getVaultMeta","webvault_id","webvault_name","webvault_label","request","webvault_create","uuid","webvault_read","update","webvault_update","delete","webvault_delete","unlock","webvault_unlock","lock","webvault_lock","webvault_buffer","r2","v0","__wbindgen_free","$c7c9fc8d1fba3aba$exports","getBundleURL","resolve","$4ce57fe94e553770$export$2e2bcd8739ae039","async","$4ce57fe94e553770$var$init","input","URL","imports","wbg","__wbg_log_7b91984099667bb9","arg0","arg1","console","log","__wbindgen_json_serialize","ptr0","stringify","__wbindgen_malloc","__wbindgen_realloc","len0","__wbindgen_object_drop_ref","__wbindgen_error_new","__wbindgen_json_parse","__wbg_new_693216e109162396","__wbg_stack_0ddaca5d1abfb52f","__wbg_error_09919627ac0992f5","error","__wbg_getRandomValues_99bbe8a65f4aef87","getRandomValues","arguments","__wbg_randomFillSync_378e02b85af41ab6","arg2","randomFillSync","__wbg_process_5729605ce9d34ea8","process","__wbindgen_is_object","val","__wbg_versions_531e16e1a776ee97","versions","__wbg_node_18b58a160b60d170","node","__wbindgen_is_string","__wbg_static_accessor_NODE_MODULE_bdc5ca9096c68aeb","module","__wbg_require_edfaedd93e302925","require","__wbg_crypto_2bc4d5b05161de5b","crypto","__wbg_msCrypto_d003eebe62c636a9","msCrypto","__wbg_newnoargs_f579424187aa1717","Function","__wbg_call_89558c3e96703ca1","call","__wbindgen_object_clone_ref","__wbg_self_e23d74ae45fb17d1","self","__wbg_window_b4be7f48b24ac56e","window","__wbg_globalThis_d61b1f48a57191ae","globalThis","__wbg_global_e7669da72fd7f239","$parcel$global","global","__wbindgen_is_undefined","__wbg_buffer_5e74a88a1424a2e0","__wbg_new_e3b800e570795b3c","__wbg_set_5b8081e9d002f0df","__wbg_length_30803400a8f15c59","__wbg_newwithlength_5f4ce114a24dfe1e","__wbg_subarray_a68f835ca2af506f","__wbindgen_throw","__wbindgen_memory","Request","fetch","instance","Response","WebAssembly","instantiateStreaming","headers","get","warn","bytes","arrayBuffer","instantiate","Instance","$4ce57fe94e553770$var$load","exports","__wbindgen_wasm_module","__wbindgen_start","$9d65ffd50b68f22a$export$be5234c0b764b6e0","Symbol","$9d65ffd50b68f22a$export$ab8f1c00731ee83e","Map","$9d65ffd50b68f22a$var$isObject","port1","port2","MessageChannel","$9d65ffd50b68f22a$export$9b7f6e342a8cbd38","port","target","$9d65ffd50b68f22a$var$throwMarker","serialized","isError","deserialize","assign","obj1","ep","callback","ev","data","type","path","argumentList","map","$9d65ffd50b68f22a$var$fromWireValue","reduce","prop","rawValue","returnValue1","parent","transfers","$9d65ffd50b68f22a$var$transferCache","$9d65ffd50b68f22a$export$c9b234447cf4ef7c","value1","Promise","catch","then","returnValue","wireValue","transferables","$9d65ffd50b68f22a$var$toWireValue","postMessage","removeEventListener","$9d65ffd50b68f22a$var$closeEndPoint","start","endpoint","close","isReleased","Proxy","isProxyReleased","$9d65ffd50b68f22a$export$89981d4b8d9f48aa","$9d65ffd50b68f22a$var$requestResponseMessage","p","toString","r","bind","$9d65ffd50b68f22a$var$createProxy","_target","$9d65ffd50b68f22a$var$throwIfProxyReleased","_thisArg","rawArgumentList","last","$9d65ffd50b68f22a$export$39fb953702b7fcd7","$9d65ffd50b68f22a$var$processArguments","construct","$9d65ffd50b68f22a$export$923f96dd5afa9ce6","processed","v","arr","concat","WeakMap","handler","canHandle","serializedValue","serialize","msg","ready","WebVault","WebSigner","Signup","generatePassphrase","words"],"version":3,"file":"worker.c10b0520.js.map"}